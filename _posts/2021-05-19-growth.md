---
layout: post
title: Growth
image: /img/sprout.jpg
---

How do you know if you've gotten better at something? 

The first four years of my post college career were a wash - looking back I spent a lot of that time idling. It feels like stagnation in the mental sense, but there wasn't a sense that I was stuck a static environment - I just didn't know better. But when looking at job listings and their requirements and the tech they require applicants to know, is any of the tech actually better? 

How do you get to a point in tech where you can envision a better ecosystem, or a better way of doing things? In life it's pretty simple to see improvements in quality using senses, but in tech how can you tell if React or Preact or Elixir or Go or whatever is better?

One idea is how frustrating something is to use. If figuring out the exact type TypeScript needs in order to not error out is baffling and you end up just using `any` for everything that's not a `string` or `number` then is it really better? Or is it actually a problem with how *I'm* using it? 

A problem with the frustration test is that frustrations dwindle over time (otherwise you'd go insane), or rather, you begin to acclimate to them. Logging in 5 times just to get to the point where you can start running your build environment sounds awful, but over time becomes normal. 

So maybe there's a point just after initial exposure, and right before acclimitization, where frustrations toward a library or framework or the way something is done is valid and these are signs that *something* could be better.

*Or maybe you just suck*

There's still sometimes the problem of not getting something, maybe due to nerves, the perception of your own intelligence, or just because it's difficult.

In what sense can problems in tech be difficult though?

With interview algorithm questions, some of them can be difficult without knowledge of a specific function or data structure. Others require an insight into the underlying pattern being presented. And there's still this feeling that a *really good* programmer could derive these missing functions from (insert hand-wavey motion) first principles. Even so, I don't see the lack of exposure to a function or tool relating at all to the lack of ability to acquire that tool, especially with everyone carrying around an internet sized toolbox in their pockets at all times. 

Maybe the correct way to evaluate someone is partially on their ability to sift through the internet toolbox, and partially on the size of their working toolbox - the functions and structures they keep close at hand.

Or maybe we're all just monkeys glueing things together, who knows.
